import os
import re

class ProjectCrystallizer:
    def __init__(self):
        self.base_path = "./app"
        self.ignore_files = ["__init__.py", "nexus.py"]

    def _to_pascal_case(self, name: str) -> str:
        return "".join(word.capitalize() for word in name.split("_"))

    def crystallize(self):
        print("üíé [CRISTALIZADOR] Iniciando Opera√ß√£o de Auto-Cura...")

        for root, _, files in os.walk(self.base_path):
            if "__init__.py" not in files:
                with open(os.path.join(root, "__init__.py"), "w", encoding="utf-8") as f:
                    f.write("# Auto-generated by JARVIS\n")

            for file in files:
                if file.endswith(".py") and file not in self.ignore_files:
                    self._fix_file(os.path.join(root, file), file[:-3])

        print("‚úÖ [CRISTALIZADOR] Projeto Cristalizado e Estabilizado.")

    def _fix_file(self, file_path, file_id):
        expected_class = self._to_pascal_case(file_id)

        with open(file_path, "r", encoding="utf-8") as f:
            lines = f.readlines()

        # Limpeza de emerg√™ncia: Remove linhas corrompidas como 'Mission = class'
        clean_lines = [l for l in lines if not re.search(rf"^{expected_class}\s*=\s*class\b", l)]
        content = "".join(clean_lines)

        # Busca classes reais definidas no arquivo
        # Ignora classes que s√£o apenas aliases ou coment√°rios
        found_classes = re.findall(r"^class\s+([a-zA-Z0-9_]+)", content, re.MULTILINE)

        if found_classes:
            # Se a classe esperada j√° existe como uma defini√ß√£o real de classe, n√£o faz nada
            if expected_class in found_classes:
                if len(lines) != len(clean_lines): # Se limpou algo, salva
                    with open(file_path, "w", encoding="utf-8") as f:
                        f.write(content)
                return

            # Se a classe esperada N√ÉO existe, mas outras existem, cria alias para a PRIMEIRA classe
            primary_class = found_classes[0]
            alias_line = f"{expected_class} = {primary_class}"

            if alias_line not in content:
                print(f"  [üîó] Linkando: {expected_class} -> {primary_class} em {file_id}.py")
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(content.rstrip() + f"\n\n# Nexus Compatibility\n{alias_line}\n")
            return

        # Se n√£o h√° nenhuma classe, envelopa o conte√∫do
        if content.strip() and not content.strip().startswith("class "):
            print(f"  [üì¶] Envelopando script: {file_id}.py")
            indented = "\n".join([f"    {l}" if l.strip() else l for l in content.split('\n')])

            new_content = (
                f"class {expected_class}:\n"
                f"    def __init__(self, *args, **kwargs):\n"
                f"        pass\n\n"
                f"{indented}\n"
            )
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(new_content)

if __name__ == "__main__":
    ProjectCrystallizer().crystallize()
