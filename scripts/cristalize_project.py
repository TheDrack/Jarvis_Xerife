import os
import re
import logging
from pathlib import Path

# Configura√ß√£o de Logging para transpar√™ncia total na execu√ß√£o
logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger("Crystallizer")

class ProjectCrystallizer:
    def __init__(self, base_path: str = "./app"):
        self.base_path = Path(base_path)
        self.ignore_files = {
            "__init__.py",
            "nexus.py",
            "nexuscomponent.py",
        }

        # Import padronizado para todos os componentes
        self.component_import = (
            "from app.core.nexuscomponent import NexusComponent\n\n"
        )

    def _to_pascal_case(self, name: str) -> str:
        """Converte snake_case para PascalCase (ex: monitor_cpu -> MonitorCpu)"""
        return "".join(word.capitalize() for word in name.split("_"))

    def crystallize(self):
        logger.info("üíé [CRISTALIZADOR] Iniciando Opera√ß√£o de Auto-Cura...")

        if not self.base_path.exists():
            logger.error(f"Caminho base {self.base_path} n√£o encontrado.")
            return

        for root, _, files in os.walk(self.base_path):
            root_path = Path(root)

            # Garante que todo diret√≥rio seja um pacote Python v√°lido
            init_file = root_path / "__init__.py"
            if not init_file.exists():
                init_file.write_text("# Auto-generated by JARVIS\n", encoding="utf-8")

            for file in files:
                if not file.endswith(".py") or file in self.ignore_files:
                    continue

                self._fix_file(root_path / file)

        logger.info("‚úÖ [CRISTALIZADOR] Projeto Cristalizado e Estabilizado.")

    def _fix_file(self, file_path: Path):
        file_id = file_path.stem
        expected_class = self._to_pascal_case(file_id)

        try:
            content = file_path.read_text(encoding="utf-8")
        except Exception as e:
            logger.error(f"Erro ao ler {file_path}: {e}")
            return

        # Limpeza: Remove atribui√ß√µes corrompidas onde a classe tenta ser igual a 'class'
        content = re.sub(
            rf"^{expected_class}\s*=\s*class\b.*$",
            "",
            content,
            flags=re.MULTILINE,
        )

        # Identifica classes existentes no arquivo
        found_classes = re.findall(
            r"^class\s+([A-Za-z0-9_]+)",
            content,
            flags=re.MULTILINE,
        )

        # CEN√ÅRIO 1: A classe esperada j√° existe
        if expected_class in found_classes:
            self._ensure_contract(file_path, content, expected_class)
            return

        # CEN√ÅRIO 2: Existe uma classe, mas com nome diferente do arquivo (Cria Alias)
        if found_classes:
            primary_class = found_classes[0]
            alias_line = f"{expected_class} = {primary_class}"

            if alias_line not in content:
                logger.info(f"  [üîó] Criando Alias: {expected_class} -> {primary_class}")
                content = content.rstrip() + f"\n\n# Nexus Compatibility\n{alias_line}\n"

            self._ensure_contract(file_path, content, primary_class)
            return

        # CEN√ÅRIO 3: C√≥digo solto (Script). Envelopa em uma classe NexusComponent.
        if content.strip():
            logger.info(f"  [üì¶] Envelopando script: {file_path.name}")

            # Melhoria: Indenta√ß√£o segura preservando linhas vazias
            indented = "\n".join(
                f"        {line}" if line.strip() else line
                for line in content.splitlines()
            )

            new_content = (
                f"{self.component_import}"
                f"class {expected_class}(NexusComponent):\n"
                f"    def execute(self, context: dict):\n"
                f"        \"\"\"Execu√ß√£o automatizada do script original\"\"\"\n"
                f"{indented}\n"
            )

            file_path.write_text(new_content, encoding="utf-8")

    def _ensure_contract(self, file_path: Path, content: str, class_name: str):
        """Garante que a classe herda de NexusComponent e possui o m√©todo execute."""
        updated = False

        # Injeta o import se necess√°rio
        if "NexusComponent" not in content:
            content = self.component_import + content
            updated = True

        # Regex para encontrar a defini√ß√£o da classe e capturar heran√ßa
        class_pattern = rf"class\s+({class_name})\s*(\(([^)]*)\))?:"
        match = re.search(class_pattern, content)

        if not match:
            return

        full_class_def = match.group(0)
        inheritance = match.group(3) if match.group(3) else ""

        # Garante heran√ßa de NexusComponent
        if "NexusComponent" not in inheritance:
            new_inheritance = f"({inheritance}, NexusComponent)" if inheritance else "(NexusComponent)"
            new_class_def = f"class {class_name}{new_inheritance}:"
            content = content.replace(full_class_def, new_class_def)
            updated = True

        # Garante exist√™ncia do m√©todo execute
        # Procuramos o m√©todo apenas dentro do escopo da classe para evitar falsos positivos
        class_block_start = content.find(new_class_def if updated else full_class_def)
        if "def execute(" not in content[class_block_start:]:
            logger.info(f"  [‚ûï] Injetando execute() em {class_name}")
            insertion_point = content.find(":", class_block_start) + 1
            insert = (
                f"\n    def execute(self, context: dict):\n"
                f"        # TODO: Implementar l√≥gica do componente\n"
                f"        raise NotImplementedError(\"M√©todo execute n√£o implementado em {class_name}\")\n"
            )
            content = content[:insertion_point] + insert + content[insertion_point:]
            updated = True

        if updated:
            file_path.write_text(content, encoding="utf-8")


if __name__ == "__main__":
    # Executa a cristaliza√ß√£o no diret√≥rio padr√£o
    ProjectCrystallizer().crystallize()
