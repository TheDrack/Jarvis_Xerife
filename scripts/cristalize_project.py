# scripts/cristalize_project.py
import os
import re

class ProjectCrystallizer:
    def __init__(self):
        self.base_path = "./app"
        self.ignore_files = ["__init__.py", "nexus.py"]

    def _to_pascal_case(self, name: str) -> str:
        return "".join(word.capitalize() for word in name.split("_"))

    def crystallize(self):
        print("üíé [CRISTALIZADOR] Iniciando Refatora√ß√£o de Seguran√ßa...")
        
        for root, _, files in os.walk(self.base_path):
            if "__init__.py" not in files:
                with open(os.path.join(root, "__init__.py"), "w", encoding="utf-8") as f:
                    f.write("# Auto-generated by JARVIS\n")

            for file in files:
                if file.endswith(".py") and file not in self.ignore_files:
                    self._fix_file(os.path.join(root, file), file[:-3])

        print("‚úÖ [CRISTALIZADOR] Cicatrizado sem erros de sintaxe.")

    def _fix_file(self, file_path, file_id):
        expected_class = self._to_pascal_case(file_id)
        
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Regex robusto para achar o nome da PRIMEIRA classe do arquivo
        class_match = re.search(r"^class\s+([a-zA-Z0-9_]+)", content, re.MULTILINE)
        
        if class_match:
            existing_class = class_match.group(1)
            
            # Se a classe existe e √© diferente da esperada, cria o link de compatibilidade
            # Mas verifica se j√° n√£o existe o alias para n√£o duplicar ou quebrar
            alias_line = f"{expected_class} = {existing_class}"
            if existing_class != expected_class and alias_line not in content:
                print(f"  [üîó] Linkando: {expected_class} -> {existing_class}")
                with open(file_path, "a", encoding="utf-8") as f:
                    f.write(f"\n\n# Nexus Compatibility\n{alias_line}\n")
            return

        # Se n√£o tem classe, e n√£o √© um arquivo vazio, envelopa com seguran√ßa
        if content.strip() and not content.startswith("class "):
            print(f"  [üì¶] Envelopando script: {file_id}.py")
            lines = content.split('\n')
            indented = "\n".join([f"    {line}" if line.strip() else line for line in lines])
            
            new_content = (
                f"class {expected_class}:\n"
                f"    def __init__(self, *args, **kwargs):\n"
                f"        pass\n\n"
                f"{indented}\n"
            )
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(new_content)

if __name__ == "__main__":
    ProjectCrystallizer().crystallize()
