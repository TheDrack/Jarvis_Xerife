import os
import re
import logging
from pathlib import Path

# Configura√ß√£o de Logging
logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger("Crystallizer")

class ProjectCrystallizer:
    def __init__(self, base_path: str = "./app"):
        self.base_path = Path(base_path)
        # Prote√ß√£o total para o core e arquivos de infraestrutura
        self.ignore_folders = {"core", "infrastructure/database"} 
        self.ignore_files = {
            "__init__.py",
            "nexus.py",
            "nexuscomponent.py",
            "crystallizer_engine.py" # Protege a si mesmo
        }

        self.component_import = (
            "from app.core.nexuscomponent import NexusComponent\n"
        )

    def _to_pascal_case(self, name: str) -> str:
        return "".join(word.capitalize() for word in name.split("_"))

    def crystallize(self):
        logger.info("üíé [CRISTALIZADOR] Iniciando Opera√ß√£o de Auto-Cura Segura...")

        for root, dirs, files in os.walk(self.base_path):
            root_path = Path(root)
            
            # Pula pastas protegidas (Core do sistema)
            if any(folder in root_path.parts for folder in self.ignore_folders):
                continue

            # Garante __init__.py
            init_file = root_path / "__init__.py"
            if not init_file.exists():
                init_file.write_text("# Auto-generated by JARVIS\n", encoding="utf-8")

            for file in files:
                if not file.endswith(".py") or file in self.ignore_files:
                    continue
                
                self._fix_file(root_path / file)

        logger.info("‚úÖ [CRISTALIZADOR] Estabiliza√ß√£o conclu√≠da sem conflitos de MRO.")

    def _fix_file(self, file_path: Path):
        file_id = file_path.stem
        expected_class = self._to_pascal_case(file_id)

        try:
            content = file_path.read_text(encoding="utf-8")
        except Exception as e:
            logger.error(f"Erro ao ler {file_path}: {e}")
            return

        # 1. Identifica classes existentes
        found_classes = re.findall(r"^class\s+([A-Za-z0-9_]+)", content, flags=re.MULTILINE)

        # CEN√ÅRIO: Classe correta j√° existe ou precisa de alias
        if found_classes:
            target_class = expected_class if expected_class in found_classes else found_classes[0]
            
            # Se n√£o for a classe esperada, cria o Alias de compatibilidade
            if target_class != expected_class:
                alias_line = f"{expected_class} = {target_class}"
                if alias_line not in content:
                    content = content.rstrip() + f"\n\n# Nexus Compatibility\n{alias_line}\n"
            
            self._ensure_contract(file_path, content, target_class)
            return

        # CEN√ÅRIO: Script solto (Envelopamento)
        if content.strip():
            logger.info(f"  [üì¶] Envelopando script: {file_path.name}")
            indented = "\n".join(f"        {line}" if line.strip() else line for line in content.splitlines())
            
            new_content = (
                f"from app.core.nexuscomponent import NexusComponent\n\n"
                f"class {expected_class}(NexusComponent):\n"
                f"    def execute(self, context: dict):\n"
                f"{indented}\n"
            )
            file_path.write_text(new_content, encoding="utf-8")

    def _ensure_contract(self, file_path: Path, content: str, class_name: str):
        updated = False

        # Import do componente base
        if "NexusComponent" not in content:
            content = self.component_import + content
            updated = True

        # CORRE√á√ÉO DE MRO: Localiza a defini√ß√£o da classe e ajusta a heran√ßa
        # Procura por: class Nome(Heran√ßa): ou class Nome:
        class_pattern = rf"class\s+({class_name})\s*(\(([^)]*)\))?:"
        match = re.search(class_pattern, content)

        if match:
            full_def = match.group(0)
            inheritance = match.group(3) if match.group(3) else ""

            if "NexusComponent" not in inheritance:
                # Se tiver ABC, NexusComponent DEVE vir antes para evitar erro de MRO
                if "ABC" in inheritance:
                    new_inheritance = f"(NexusComponent, {inheritance})"
                elif inheritance:
                    new_inheritance = f"(NexusComponent, {inheritance})"
                else:
                    new_inheritance = "(NexusComponent)"
                
                new_def = f"class {class_name}{new_inheritance}:"
                content = content.replace(full_def, new_def)
                updated = True

        # Inje√ß√£o do m√©todo execute (apenas se n√£o for uma Interface Abstrata pura)
        if "def execute(" not in content and "@abstractmethod" not in content:
            logger.info(f"  [‚ûï] Injetando execute() em {class_name}")
            # Insere logo ap√≥s os dois pontos da classe
            class_idx = content.find(f"class {class_name}")
            colon_idx = content.find(":", class_idx) + 1
            
            insert = (
                f"\n    def execute(self, context: dict):\n"
                f"        raise NotImplementedError(\"Implementa√ß√£o autom√°tica via Cristalizador\")\n"
            )
            content = content[:colon_idx] + insert + content[colon_idx:]
            updated = True

        if updated:
            file_path.write_text(content, encoding="utf-8")

if __name__ == "__main__":
    ProjectCrystallizer().crystallize()
