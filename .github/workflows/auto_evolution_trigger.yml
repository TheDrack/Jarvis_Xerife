name: "ðŸš€ JARVIS: Auto-EvoluÃ§Ã£o e Sincronia"

on:
  pull_request:
    branches: [ main ]
    types: [ closed ] # SÃ³ dispara quando a PR fecha
  workflow_dispatch: # Gatilho manual do Comandante

permissions:
  contents: write
  pull-requests: write

jobs:
  process_evolution:
    name: "ðŸ§¬ Orquestrador de Ciclo"
    # SÃ“ EXECUTA se a PR foi realmente fundida (merged), e nÃ£o apenas fechada/cancelada
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Environment
        uses: astral-sh/setup-uv@v5

      - name: ðŸ§  Executar LÃ³gica de Ciclo
        env:
          GH_TOKEN: ${{ github.token }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          # Capturamos os dados da PR para a lÃ³gica interna
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          uv venv --python 3.13
          uv pip install sqlmodel pydantic requests groq
          export PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$(pwd)"
          
          python - << 'PYCODE'
          import os, sys
          from app.application.services.auto_evolution import AutoEvolutionService
          
          auto = AutoEvolutionService()
          pr_title = os.environ.get('PR_TITLE', '')
          
          # 1. Identifica se a PR que acabou de ser fundida era de Auto-EvoluÃ§Ã£o
          # Verificamos se o tÃ­tulo contÃ©m nosso prefixo padrÃ£o
          is_evolution_pr = "ðŸ§¬ EvoluÃ§Ã£o:" in pr_title or "[Auto-Evolution]" in pr_title
          
          if is_evolution_pr:
              print(f"ðŸŽ¯ Merge de evoluÃ§Ã£o confirmado: {pr_title}")
              # Extrai o nome da missÃ£o (ex: de "ðŸ§¬ EvoluÃ§Ã£o: TaskRunner" para "TaskRunner")
              mission_name = pr_title.split("ðŸ§¬ EvoluÃ§Ã£o:")[-1].strip()
              
              if auto.mark_mission_as_completed(mission_name):
                  os.system("git config --global user.name 'Jarvis-AutoEvolution'")
                  os.system("git config --global user.email 'jarvis@bot.com'")
                  os.system("git add docs/ROADMAP.md")
                  os.system("git commit -m '[Auto-Evolution] Roadmap Synchronized âœ…'")
                  os.system("git push origin main")
                  print(f"âœ… MissÃ£o '{mission_name}' concluÃ­da no Roadmap.")
              
          # 2. ApÃ³s atualizar (ou se nÃ£o era PR de evoluÃ§Ã£o), busca a PRÃ“XIMA missÃ£o
          print("ðŸš€ Buscando prÃ³xima fronteira no Roadmap...")
          next_mission = auto.find_next_mission()
          
          if next_mission:
              desc = next_mission['description']
              print(f"ðŸ“ PrÃ³xima missÃ£o: {desc}")
              
              # Dispara o mutador para criar a nova branch e abrir a PR
              # O mutador deve dar o 'git push' da branch e o 'gh pr create'
              os.system(f"python scripts/metabolism_mutator.py --intent 'auto-evolution' --mission '{desc}'")
          else:
              print("ðŸ’¤ Sistema em equilÃ­brio. Nenhuma missÃ£o pendente.")
          PYCODE
